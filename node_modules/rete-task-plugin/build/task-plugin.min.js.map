{"version":3,"file":"task-plugin.min.js","sources":["../src/task.js","../src/index.js"],"sourcesContent":["export class Task {\n\n    constructor(inputs, component, worker) {\n        this.inputs = inputs;\n        this.component = component;\n        this.worker = worker;\n        this.next = [];\n        this.outputData = null;\n        this.closed = [];\n\n        this.getInputs('option').forEach(key => {\n            this.inputs[key].forEach(con => {\n                con.task.next.push({ key: con.key, task: this });\n            })\n        });\n    }\n\n    getInputs(type) {\n        return Object.keys(this.inputs)\n            .filter(key => this.inputs[key][0])\n            .filter(key => this.inputs[key][0].type === type)\n    }\n\n    reset() {\n        this.outputData = null;\n    }\n\n    async run(data, needReset = true, garbage = [], propagate = true) {\n        if (needReset)\n            garbage.push(this);\n        \n        if (!this.outputData) {\n            var inputs = {};\n\n            await Promise.all(this.getInputs('output').map(async key => {\n                inputs[key] = await Promise.all(this.inputs[key].map(async con => {\n                    if (con) {\n                        await con.task.run(data, false, garbage, false);\n                        return con.task.outputData[con.key];\n                    }\n                }));\n            }));\n\n            this.outputData = await this.worker(this, inputs, data);\n\n            if (propagate)\n                await Promise.all(\n                    this.next\n                        .filter(f => !this.closed.includes(f.key))\n                        .map(async f => \n                            await f.task.run(data, false, garbage)\n                        )\n                );\n        }\n        \n        if (needReset)\n            garbage.map(t => t.reset());\n    }\n  \n    clone(root = true, oldTask, newTask) {\n        const inputs = Object.assign({}, this.inputs);\n\n        if (root) // prevent of adding this task to `next` property of predecessor\n            this.getInputs('option').map(key => delete inputs[key]);\n        else // replace old tasks with new copies\n            Object.keys(inputs).map(key => {\n                inputs[key] = inputs[key].map(con => ({\n                    ...con,\n                    task: con.task === oldTask ? newTask : con.task\n                }));\n            });\n    \n        const task = new Task(inputs, this.component, this.worker);\n\n        // manually add a copies of follow tasks\n        task.next = this.next.map(n => ({ key: n.key, task: n.task.clone(false, this, task)}));\n    \n        return task;\n    }\n}","import { Task } from './task';\n\nfunction install(editor) {\n        \n    editor.on('componentregister', component => {\n        if (!component.task)\n            throw 'Task plugin requires a task property in component';\n        if (component.task.outputs.constructor !== Object)\n            throw 'The \"outputs\" field must be an object whose keys correspond to the Output\\'s keys';\n        \n        const taskWorker = component.worker;\n        const taskOptions = component.task;\n\n        component.worker = (node, inputs, outputs) => {\n            const task = new Task(inputs, component, (ctx, inps, data) => {\n                return taskWorker.call(ctx, node, inps, data);\n            });\n\n            if (taskOptions.init) taskOptions.init(task, node);\n            \n            Object.keys(taskOptions.outputs).map(key => {\n                outputs[key] = { type: taskOptions.outputs[key], key, task }\n            });\n        }\n\n    });\n}\n\nexport { Task } from './task';\nexport default {\n    name: 'task-plugin',\n    install\n}"],"names":["Task","inputs","component","worker","next","outputData","closed","getInputs","forEach","key","_this","con","task","push","type","Object","keys","this","filter","_this2","data","garbage","propagate","needReset","Promise","all","map","_this3","run","f","includes","t","reset","root","oldTask","newTask","assign","n","clone","_this4","name","install","editor","on","outputs","constructor","taskWorker","taskOptions","node","ctx","inps","call","init"],"mappings":";;;;;usOAAaA,EAAb,sBAEgBC,EAAQC,EAAWC,yHACtBF,OAASA,OACTC,UAAYA,OACZC,OAASA,OACTC,KAAO,QACPC,WAAa,UACbC,OAAS,QAETC,UAAU,UAAUC,QAAQ,SAAAC,GAC7BC,EAAKT,OAAOQ,GAAKD,QAAQ,SAAAG,GACrBA,EAAIC,KAAKR,KAAKS,KAAK,CAAEJ,IAAKE,EAAIF,IAAKG,KAAMF,mEAK3CI,qBACCC,OAAOC,KAAKC,KAAKhB,QACnBiB,OAAO,SAAAT,UAAOU,EAAKlB,OAAOQ,GAAK,KAC/BS,OAAO,SAAAT,UAAOU,EAAKlB,OAAOQ,GAAK,GAAGK,OAASA,yCAI3CT,WAAa,gEAGZe,oHAAwBC,iCAAU,GAAIC,sCAAhCC,uCAERF,EAAQR,KAAKI,MAEZA,KAAKZ,mCACFJ,EAAS,YAEPuB,QAAQC,IAAIR,KAAKV,UAAU,UAAUmB,+CAAI,WAAMjB,kGAC7Be,QAAQC,IAAIE,EAAK1B,OAAOQ,GAAKiB,+CAAI,WAAMf,qFACnDA,kBACMA,EAAIC,KAAKgB,IAAIR,GAAM,EAAOC,GAAS,kDAClCV,EAAIC,KAAKP,WAAWM,EAAIF,8GAHvCR,EAAOQ,mIAQaQ,KAAKd,OAAOc,KAAMhB,EAAQmB,mBAA7Cf,kBAEDiB,mBACME,QAAQC,IACVR,KAAKb,KACAc,OAAO,SAAAW,UAAMF,EAAKrB,OAAOwB,SAASD,EAAEpB,OACpCiB,+CAAI,WAAMG,kGACDA,EAAEjB,KAAKgB,IAAIR,GAAM,EAAOC,oKAK9CE,GACAF,EAAQK,IAAI,SAAAK,UAAKA,EAAEC,qJAGrBC,uCAAaC,8BAASC,8BAClBlC,EAASc,OAAOqB,OAAO,GAAInB,KAAKhB,QAElCgC,OACK1B,UAAU,UAAUmB,IAAI,SAAAjB,iBAAcR,EAAOQ,KAElDM,OAAOC,KAAKf,GAAQyB,IAAI,SAAAjB,GACpBR,EAAOQ,GAAOR,EAAOQ,GAAKiB,IAAI,SAAAf,eACvBA,GACHC,KAAMD,EAAIC,OAASsB,EAAUC,EAAUxB,EAAIC,eAIjDA,EAAO,IAAIZ,EAAKC,EAAQgB,KAAKf,UAAWe,KAAKd,eAGnDS,EAAKR,KAAOa,KAAKb,KAAKsB,IAAI,SAAAW,SAAM,CAAE5B,IAAK4B,EAAE5B,IAAKG,KAAMyB,EAAEzB,KAAK0B,OAAM,EAAOC,EAAM3B,MAEvEA,oCA7Ef,SC6Be,CACX4B,KAAM,cACNC,QA7BJ,SAAiBC,GAEbA,EAAOC,GAAG,oBAAqB,SAAAzC,OACtBA,EAAUU,KACX,KAAM,uDACNV,EAAUU,KAAKgC,QAAQC,cAAgB9B,OACvC,KAAM,wFAEJ+B,EAAa5C,EAAUC,OACvB4C,EAAc7C,EAAUU,KAE9BV,EAAUC,OAAS,SAAC6C,EAAM/C,EAAQ2C,OACxBhC,EAAO,IAAIZ,EAAKC,EAAQC,EAAW,SAAC+C,EAAKC,EAAM9B,UAC1C0B,EAAWK,KAAKF,EAAKD,EAAME,EAAM9B,KAGxC2B,EAAYK,MAAML,EAAYK,KAAKxC,EAAMoC,GAE7CjC,OAAOC,KAAK+B,EAAYH,SAASlB,IAAI,SAAAjB,GACjCmC,EAAQnC,GAAO,CAAEK,KAAMiC,EAAYH,QAAQnC,GAAMA,IAAAA,EAAKG,KAAAA"}